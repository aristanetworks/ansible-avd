# L3LS EVPN design

## Overview

is a role that provides an abstracted data model to deploy an L3 leaf & spine topolgoy running EVPN.

| Underlay | Overlay | Topology |
| -------- | ------- | ---------- |
| eBGP | eBGP | [ 3 stage, 5 stage ] + L2 Leafs |
| ISIS | eBGP | [ 3 stage ] + L2 Leafs |
| ISIS | iBGP | [ 3 stage ] + L2 Leafs |
| OSPF | eBGP | [ 3 stage ] + L2 Leafs |
| OSPF | iBGP | [ 3 stage ] + L2 Leafs |

<div style="text-align:center">
  <img src="../../media/topology.gif" />
</div>

Across all designs the following functionality is provided:

- Flexible placement of EVPN RS or RR, including dedicated overlay controller
- EVPN service definition: Layer 2 and Layer 3
- L3 Edge port definition
- Server edge ports definition

### Inventory Structure

The inventory must have a dedicated group for super-spines and every leaf-spine POD. Example:

```yaml
all:
  children:
    < DC-group-name >:
      children:
        < Super Spines group name >:
          hosts:
            < super-spine name >:
              ansible_host: < management IP >
            < super-spine name >:
              ansible_host: < management IP >
            ...
        < DC POD 1 group name >:
          children:
            < spines group >:
              <-- omitted -->
            < leaf group >:
              <-- omitted -->
```

## Custom EOS Structured Configuration

Custom EOS Structured Configuration keys can be set on any level using the name
of the corresponding `eos_cli_config_gen` key prefixed with content of `custom_structured_configuration_prefix`.
The content of Custom Structured Configuration variables will be combined with the structured config generated by the eos_designs role.
Lists are replaced. Dictionaries are updated. The combine is done recursively, so it is possible to update a sub-key of a variable set by
`eos_designs` role already.

 Example:

```yaml
custom_structured_configuration_name_server:
  nodes:
    - 10.2.3.4
custom_structured_configuration_ethernet_interfaces:
  Ethernet4000:
    description: My test
    ip_address: 10.1.2.3/12
    shutdown: false
    type: routed
    mtu: 1500
    peer: MY-own-peer
    peer_interface: Ethernet123
    peer_type: my_precious
```

In this example the contents of the `name_server.nodes` variable in the Structured Configuration will be replaced by the list `[ 10.2.3.4 ]`
and `Ethernet4000` will be added to the `ethernet_interfaces` dictionary in the Structured Configuration.

`custom_structured_configuration_prefix` allows the user to customize the prefix for Custom Structured Configuration variables.
Default value is `custom_structured_configuration_`. Remember to include any delimiter like the last `_` in this case.
It is possible to specify a list of prefixes, which will all be merged one by one. The order of merge will start from beginning of the list, which means that keys defined in the later prefixes will be able to override keys defined in previous ones.

```yaml
custom_structured_configuration_prefix: < variable_prefix, default -> "custom_structured_configuration_" >
#or
custom_structured_configuration_prefix: [ < variable_prefix_1 > , < variable_prefix_2 > , < variable_prefix_3 > ]
```

Example using multiple prefixes:

```yaml
custom_structured_configuration_prefix: [ my_dci_ , my_special_dci_ ]

my_dci_ethernet_interfaces:
  Ethernet4000:
    description: My test
    ip_address: 10.1.2.3/12
    shutdown: false
    type: routed
    mtu: 1500
    peer: MY-own-peer
    peer_interface: Ethernet123
    peer_type: my_precious

my_special_dci_ethernet_interfaces:
  Ethernet4000:
    ip_address: 10.3.2.1/21
```

In this example  `Ethernet4000` will be added to the `ethernet_interfaces` dictionary in the Structured Configuration and the ip_address will be `10.3.2.1/21` since ip_adddress was overridden on the later `custom_scructured_configuration_prefix`

## vEOS-LAB Know Caveats and Recommendations

- vEOS-LAB is a great tool to learn and test ansible-avd automation framework. In fact, this is the primary tool leveraged by Arista Ansible Team, for development and testing efforts.
- vEOS-lab enables you to create and run replicas of physical networks within a risk free virtual environment.
- Virtual networks created with vEOS-lab can be used for network modeling, planning for new services, or validating new features and functionality for the installed network.
- vEOS-lab is not a network simulator but the exact EOS implementation that runs on the hardware platforms.
- Supported features are documented here: [Arista EOS overview](https://www.arista.com/en/products/eos)

However, because vEOS-LAB implements a virtual data plane there are known caveats and adjustments that are required to default arista.avd settings:

**Variables adjustments required for vEOS-LAB:**

```yaml
# Disable update wait-for-convergence and update wait-for-install, which is not supported in vEOS-LAB.
spine_bgp_defaults:
#  - update wait-for-convergence
#  - update wait-install
  - no bgp default ipv4-unicast
  - distance bgp 20 200 200
  - graceful-restart restart-time 300
  - graceful-restart

leaf_bgp_defaults:
#  - update wait-install
  - no bgp default ipv4-unicast
  - distance bgp 20 200 200
  - graceful-restart restart-time 300
  - graceful-restart

# Update p2p mtu 9000 -> 1500, MTU 9000 not supported in vEOS-LAB.
p2p_uplinks_mtu: 1500

# Adjust default bfd values, to avoid high CPU.
bfd_multihop:
  interval: 1200
  min_rx: 1200
  multiplier: 3
```
